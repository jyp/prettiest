
* State of the art
  
- Hughes. Pretty, but makes eager decisions (sec. 7.4) so the results are ugly.
- Wadler. Much simpler, but produces even uglier things.

Let us detail these claims

Say we pretty print s-exps, and we allow for them to be printed either horizontally, or
vertically like so:
(a
 b
 c
 d)

(ie. we want the elements to be aligned on the 1st parens)

With Wadler we can implement this as:

"(" <> nest 1 (mconcat xs) <> ")"

And we try to prettify:

(a b c (d e f))

in this width:
###########

We get:

(a
 b
 c
 (d e f))

but never the shorter:

###########
(a b c (d
        e
        f))

Indeed, it tries to fit the whole text on one line. This fails, so the
vertical option is chosen.


Hughes choses the prettier option, bu also suffers from the problem of
making eager decisions:

Consider:

(axbxcxd ((a b c d) (a b c d) (a b c d) (a b c d) (a b c d)))

To fit:
###############

Hughes tries to fit as much as possible on the 1st line. In this case, it succeeds:

###############
(axbxcxd ((a

But then, it has committed to this indentation level, and we get a
very long output:

###############
(axbxcxd ((a
           b
           c
           d)
          (a
           b
           c
           d)
          (a
           b
           c
           d)
          (a
           b
           c
           d)
          (a
           b
           c
           d)))
###############

While this choice could have been made:

###############
(axbxcxd
 ((a b c d)
  (a b c d)
  (a b c d)
  (a b c d)
  (a b c d))
###############

These examples may feel contrieved. In reality they occur all the
time.

Can we implement a library that choses always the prettiest layout?
Can we take the best possible choice, while not getting lost in
backtracking? Yep.

* Specification of the problem
** Syntax

nil :: Doc
(<>) :: Doc -> Doc -> Doc
text :: String -> Doc
line :: Doc
nest :: Int -> Doc -> Doc
align :: Doc -> Doc

(same as Leijen)

** Semantics

layout :: Doc -> String

Define a interpretation of the combinators as a relation Doc ‚ü∂ Layout
(aop style relations, folds, etc.)

** Some quickspec laws
text [] = empty

Size 3, 36 schemas to consider:
x <> empty = x
empty <> x = x
nest i empty = empty
nest 0 x = x

Size 4, 38 schemas to consider:
nest i (text xs) = text xs

Size 5, 107 schemas to consider:
text xs <> text ys = text (xs ++ ys)
(x <> y) <> z = x <> (y <> z)
nest i (nest j x) = nest j (nest i x)
nest (i + j) x = nest i (nest j x)

Size 6, 154 schemas to consider:
nest i (x <> text xs) = nest i x <> text xs
nest i (text xs <> x) = text xs <> nest i x

Size 7, 383 schemas to consider:
nest i x <> nest i y = nest i (x <> y)

Size 8, 722 schemas to consider:

Size 9, 1745 schemas to consider:

7179 events created in total (1295 schemas, 1027 terms, 4823 creation, 34 miscellaneous).
34 hooks installed.

== Signature ==
group :: Doc1 -> Doc1
align :: Doc1 -> Doc1

Size 1, 13 schemas to consider:

Size 2, 27 schemas to consider:
align empty = empty
group empty = empty

Size 3, 55 schemas to consider:
align (align x) = align x
align (group line) = group line
align (text xs) = text xs
group (align x) = align (group x)
group (group x) = group x
group (text xs) = text xs

Size 4, 108 schemas to consider:
line <> align x = line <> x
group (nest i line) = group line
nest i (align x) = align x
nest i (group x) = group (nest i x)

Size 5, 264 schemas to consider:
align line <> align x = align (line <> x)
align (x <> align y) = align x <> align y
align (align x <> y) = align (x <> y)
group (x <> text xs) = group x <> text xs
group (group line <> line) = group line <> group line
group (text xs <> x) = text xs <> group x

Size 6, 724 schemas to consider:
group (group x <> group y) = group x <> group y

* Derivation.
 TODO

The solution is to pretty-print line by line (so we consider only
shortest resuts).  We prune dominated solutions. Each solution is
assigned a pair (i,p) of current indentation (i) and progess (p).  The current
indentation is well defined, because we are at a given line. The
progress is the number of tokens that could be printed so far.

(i0,p0) > (i1,p1)  iff i0 < i1 and p0 >= p1

If there is a finite number (l) of indentation levels (traditionally
l=80), then we have only to consider l solutions after each line
break.

* Result

The algorithm has been implemented.
The result have been used sucessfully to pretty print code in papers;
allowing to fit more stuff than was possible using Wadler's approach.
